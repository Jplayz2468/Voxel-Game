<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Multiplayer Voxel Physics - Destructible Players</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: black;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
            cursor: none;
        }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 18px;
            z-index: 100;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border-radius: 5px;
        }
        #debug {
            position: absolute;
            top: 80px;
            left: 20px;
            color: lime;
            font-size: 12px;
            z-index: 100;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border-radius: 5px;
            max-width: 350px;
            font-family: monospace;
        }
        #instructions {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            font-size: 14px;
            z-index: 100;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border-radius: 5px;
            line-height: 1.4;
        }
        #connection-status {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: red;
            font-size: 14px;
            z-index: 100;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border-radius: 5px;
        }
        #ping-display {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: lime;
            font-size: 14px;
            z-index: 100;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="info">FPS: 0</div>
    <div id="debug">Connecting to server...</div>
    <div id="connection-status">üî¥ Disconnected from server</div>
    <div id="ping-display">üì° Ping: --ms</div>
    <div id="instructions">
        <strong>Destructible Voxel Players!</strong><br>
        WASD: Move<br>
        Mouse: Look around<br>
        Space: Jump<br>
        Left Click: Shoot voxels<br>
        T: Toggle Smooth/Raw mode<br>
        C: Toggle Color/Gray mode<br>
        ESC: Exit mouse control<br><br>
        <strong>GREEDY MESHED PLAYERS:</strong><br>
        üß± Players are hollow orange shells in terrain mesh<br>
        üé® SAME pipeline as terrain (guaranteed visible)<br>
        üèóÔ∏è Greedy meshing: Only exterior faces (80%+ face reduction)<br>
        üëÅÔ∏è Clean first-person view (no internal faces)<br>
        üí• Destruction: Full mesh regeneration when shot<br>
        üéØ Shoot other players apart!<br>
        üëÄ First-person view (nearby faces filtered out)<br>
        ‚ö° Server: Physics at 50 TPS<br>
        üë• Multiplayer: Each tab = player<br>
        ‚úÖ FIXED: Hollow shells prevent seeing inside bodies
    </div>

    <script>
        // ===== CONSTANTS =====
        const MOUSE_SENS = 0.002;

        // ===== MULTIPLAYER VOXEL CLIENT =====
        class MultiplayerVoxelClient {
            constructor() {
                this.setupWebGL();
                this.setupInput();
                this.connectToServer();

                // My player ID (assigned by server)
                this.myPlayerId = null;

                // Client render state - UNIFIED TERRAIN + PLAYERS
                this.renderState = {
                    vertices: [],
                    normals: [],
                    colors: [],
                    indices: [],
                    debugInfo: {
                        activeVoxels: 0,
                        totalShots: 0,
                        lastShot: 'Never',
                        totalPlayers: 0,
                        playerVoxels: 0
                    }
                };

                // Player positions for camera updates
                this.playerPositions = new Map(); // playerId -> { pos, yaw, pitch }

                // Camera state
                this.camera = {
                    pos: [64, 80, 64],
                    yaw: 0,
                    pitch: 0.3,
                    smoothPos: [64, 80, 64]
                };

                // ===== INTERPOLATION SYSTEM =====
                this.interpolation = {
                    voxelSnapshots: [], // Array of {time, voxels} - moving voxels only now
                    cameraSnapshots: [], // Array of {time, pos} for my camera
                    renderDelay: 60, // Render 60ms in the past
                    maxSnapshots: 10, // Keep last 10 snapshots
                    smoothMode: true, // Toggle for T key
                    colorMode: false // Toggle for C key
                };

                this.pointerLocked = false;
                this.keys = { w: false, s: false, a: false, d: false };
                this.connected = false;

                // Ping and input timing
                this.ping = 0;
                this.pingRequests = new Map();
                this.lastPingTime = 0;
                this.lastInputSend = 0;

                // FPS timing
                this.lastFrameTime = performance.now() / 1000;
                this.frameCount = 0;
                this.lastFpsTime = this.lastFrameTime;

                // Frame timing statistics
                this.lastFrameTiming = { total: 0 };
                this.timingFrameCount = 0;

                // Debug: Track mesh reception
                this.meshUpdatesReceived = 0;
            }

            connectToServer() {
                console.log('üîå Connecting to multiplayer server...');
                this.ws = new WebSocket('ws://localhost:8765');

                this.ws.onopen = () => {
                    console.log('‚úÖ Connected to multiplayer server!');
                    this.connected = true;
                    this.updateConnectionStatus(true);
                    this.sendToServer('requestInitialState', {});
                };

                this.ws.onclose = () => {
                    console.log('‚ùå Disconnected from server');
                    this.connected = false;
                    this.updateConnectionStatus(false);
                    setTimeout(() => this.connectToServer(), 2000);
                };

                this.ws.onerror = (error) => {
                    console.error('‚ùå WebSocket error:', error);
                    this.updateConnectionStatus(false);
                };

                this.ws.onmessage = (event) => {
                    try {
                        const message = JSON.parse(event.data);
                        this.handleServerMessage(message.type, message.data);
                    } catch (e) {
                        console.error('Error parsing server message:', e);
                    }
                };
            }

            updateConnectionStatus(connected) {
                const statusDiv = document.getElementById('connection-status');
                if (connected) {
                    statusDiv.innerHTML = 'üü¢ Connected to server';
                    statusDiv.style.color = 'lime';
                } else {
                    statusDiv.innerHTML = 'üî¥ Disconnected from server';
                    statusDiv.style.color = 'red';
                }
            }

            sendToServer(type, data) {
                if (this.connected && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify({ type, data, timestamp: performance.now() }));
                }
            }

            handleServerMessage(type, data) {
                const messageStartTime = performance.now();
                const now = performance.now();

                switch (type) {
                    case 'playerAssigned':
                        this.myPlayerId = data.playerId;
                        console.log(`üë§ Assigned player ID: ${this.myPlayerId}`);
                        break;

                    case 'renderUpdate':
                        const renderUpdateStartTime = performance.now();
                        
                        this.meshUpdatesReceived++;
                        
                        // Update unified terrain geometry (includes all players as orange cubes!)
                        const bufferUpdateStartTime = performance.now();
                        this.renderState.vertices = data.vertices;
                        this.renderState.normals = data.normals;
                        this.renderState.colors = data.colors;
                        this.renderState.indices = data.indices;
                        
                        // Filter out nearby player voxels to prevent seeing inside own body
                        if (this.myPlayerId) {
                            this.filterNearbyPlayerVoxels();
                        }
                        
                        this.updateBuffers();
                        const bufferUpdateTime = performance.now() - bufferUpdateStartTime;

                        // Add moving voxels snapshot (projectiles and debris only)
                        const snapshotStartTime = performance.now();
                        this.addVoxelSnapshot(now, data.allVoxels || []);
                        const snapshotTime = performance.now() - snapshotStartTime;

                        const renderUpdateTime = performance.now() - renderUpdateStartTime;

                        // Log if this is taking too long
                        if (renderUpdateTime > 5) {
                            console.log(`üêå Slow renderUpdate: Total=${renderUpdateTime.toFixed(2)}ms, BufferUpdate=${bufferUpdateTime.toFixed(2)}ms, Snapshot=${snapshotTime.toFixed(2)}ms, MovingVoxelCount=${(data.allVoxels||[]).length}, TerrainVertices=${data.vertices.length/3}`);
                        }

                        console.log(`üé® Received unified mesh: ${data.vertices.length/3} vertices (includes terrain + all players with greedy meshing), ${(data.allVoxels||[]).length} moving voxels`);
                        break;

                    case 'playersUpdate':
                        // Store player positions for camera updates only
                        for (const [playerId, playerData] of Object.entries(data.players || {})) {
                            this.playerPositions.set(playerId, {
                                pos: playerData.centerPos,
                                yaw: playerData.yaw,
                                pitch: playerData.pitch,
                                voxelCount: playerData.voxelCount
                            });
                        }
                        break;

                    case 'cameraUpdate':
                        // Buffer my camera position for interpolation
                        this.interpolation.cameraSnapshots.push({
                            time: now,
                            pos: [...data.pos]
                        });
                        while (this.interpolation.cameraSnapshots.length > this.interpolation.maxSnapshots) {
                            this.interpolation.cameraSnapshots.shift();
                        }
                        break;

                    case 'debugUpdate':
                        this.renderState.debugInfo = data;
                        this.updateDebugDisplay();
                        break;

                    case 'pong':
                        this.handlePong(data);
                        break;
                }

                const messageTime = performance.now() - messageStartTime;
                // Track slow message processing
                if (messageTime > 2) {
                    console.log(`üêå Slow message ${type}: ${messageTime.toFixed(2)}ms`);
                }
            }

            // ===== INTERPOLATION SYSTEM =====
            addVoxelSnapshot(time, voxels) {
                this.interpolation.voxelSnapshots.push({ time, voxels });
                while (this.interpolation.voxelSnapshots.length > this.interpolation.maxSnapshots) {
                    this.interpolation.voxelSnapshots.shift();
                }
            }

            getInterpolatedVoxels() {
                const snapshots = this.interpolation.voxelSnapshots;
                if (snapshots.length === 0) return [];

                if (!this.interpolation.smoothMode) {
                    return snapshots[snapshots.length - 1].voxels;
                }

                if (snapshots.length < 2) {
                    return snapshots[snapshots.length - 1].voxels;
                }

                const now = performance.now();
                const renderTime = now - this.interpolation.renderDelay;

                let beforeSnapshot = null;
                let afterSnapshot = null;

                for (let i = 0; i < snapshots.length - 1; i++) {
                    if (snapshots[i].time <= renderTime && snapshots[i + 1].time >= renderTime) {
                        beforeSnapshot = snapshots[i];
                        afterSnapshot = snapshots[i + 1];
                        break;
                    }
                }

                if (!beforeSnapshot || !afterSnapshot) {
                    return snapshots[snapshots.length - 1].voxels;
                }

                const totalTime = afterSnapshot.time - beforeSnapshot.time;
                const t = totalTime > 0 ? (renderTime - beforeSnapshot.time) / totalTime : 0;

                return this.interpolateVoxelsByID(beforeSnapshot.voxels, afterSnapshot.voxels, t);
            }

            getInterpolatedCameraPos() {
                const snapshots = this.interpolation.cameraSnapshots;
                if (snapshots.length === 0) return this.camera.pos;

                if (!this.interpolation.smoothMode) {
                    const latest = snapshots[snapshots.length - 1];
                    return latest ? latest.pos : this.camera.pos;
                }

                if (snapshots.length < 2) {
                    const latest = snapshots[snapshots.length - 1];
                    return latest ? latest.pos : this.camera.pos;
                }

                const now = performance.now();
                const renderTime = now - this.interpolation.renderDelay;

                let beforeSnapshot = null;
                let afterSnapshot = null;

                for (let i = 0; i < snapshots.length - 1; i++) {
                    if (snapshots[i].time <= renderTime && snapshots[i + 1].time >= renderTime) {
                        beforeSnapshot = snapshots[i];
                        afterSnapshot = snapshots[i + 1];
                        break;
                    }
                }

                if (!beforeSnapshot || !afterSnapshot) {
                    const latest = snapshots[snapshots.length - 1];
                    return latest ? latest.pos : this.camera.pos;
                }

                const totalTime = afterSnapshot.time - beforeSnapshot.time;
                const t = totalTime > 0 ? (renderTime - beforeSnapshot.time) / totalTime : 0;

                return [
                    beforeSnapshot.pos[0] + (afterSnapshot.pos[0] - beforeSnapshot.pos[0]) * t,
                    beforeSnapshot.pos[1] + (afterSnapshot.pos[1] - beforeSnapshot.pos[1]) * t,
                    beforeSnapshot.pos[2] + (afterSnapshot.pos[2] - beforeSnapshot.pos[2]) * t
                ];
            }

            interpolateVoxelsByID(voxelsA, voxelsB, t) {
                const result = [];
                const mapA = new Map();
                const mapB = new Map();

                for (const voxel of voxelsA) {
                    mapA.set(voxel.id, voxel);
                }
                for (const voxel of voxelsB) {
                    mapB.set(voxel.id, voxel);
                }

                const allIds = new Set([...mapA.keys(), ...mapB.keys()]);

                for (const id of allIds) {
                    const a = mapA.get(id);
                    const b = mapB.get(id);

                    if (a && b) {
                        result.push({
                            pos: [
                                a.pos[0] + (b.pos[0] - a.pos[0]) * t,
                                a.pos[1] + (b.pos[1] - a.pos[1]) * t,
                                a.pos[2] + (b.pos[2] - a.pos[2]) * t
                            ],
                            isProjectile: b.isProjectile,
                            isPlayerVoxel: b.isPlayerVoxel || false,
                            playerId: b.playerId || null,
                            id: b.id
                        });
                    } else if (b) {
                        result.push({
                            pos: [...b.pos],
                            isProjectile: b.isProjectile,
                            isPlayerVoxel: b.isPlayerVoxel || false,
                            playerId: b.playerId || null,
                            id: b.id,
                            alpha: t
                        });
                    } else if (a) {
                        result.push({
                            pos: [...a.pos],
                            isProjectile: a.isProjectile,
                            isPlayerVoxel: a.isPlayerVoxel || false,
                            playerId: a.playerId || null,
                            id: a.id,
                            alpha: 1 - t
                        });
                    }
                }

                return result;
            }

            // Filter out nearby player voxels to prevent seeing inside own body
            filterNearbyPlayerVoxels() {
                const vertices = this.renderState.vertices;
                const normals = this.renderState.normals;
                const colors = this.renderState.colors;
                const indices = this.renderState.indices;
                
                if (!vertices || vertices.length === 0) return;
                
                const filteredVertices = [];
                const filteredNormals = [];
                const filteredColors = [];
                const filteredIndices = [];
                
                const cameraPos = this.camera.smoothPos;
                const filterDistance = 3.0; // Hide voxels within 3 units of camera
                
                // Track vertex mapping for index updates
                const oldToNewVertexMap = new Map();
                let newVertexIndex = 0;
                
                // Process vertices in groups of triangles (every 3 indices)
                for (let i = 0; i < indices.length; i += 3) {
                    const i0 = indices[i];
                    const i1 = indices[i + 1];
                    const i2 = indices[i + 2];
                    
                    // Get triangle vertices
                    const v0 = [vertices[i0 * 3], vertices[i0 * 3 + 1], vertices[i0 * 3 + 2]];
                    const v1 = [vertices[i1 * 3], vertices[i1 * 3 + 1], vertices[i1 * 3 + 2]];
                    const v2 = [vertices[i2 * 3], vertices[i2 * 3 + 1], vertices[i2 * 3 + 2]];
                    
                    // Get triangle colors
                    const c0 = [colors[i0 * 3], colors[i0 * 3 + 1], colors[i0 * 3 + 2]];
                    
                    // Check if this is an orange player voxel (approximately orange color)
                    const isPlayerVoxel = (c0[0] > 0.8 && c0[1] > 0.4 && c0[1] < 0.6 && c0[2] < 0.2);
                    
                    if (isPlayerVoxel) {
                        // Calculate triangle center
                        const centerX = (v0[0] + v1[0] + v2[0]) / 3;
                        const centerY = (v0[1] + v1[1] + v2[1]) / 3;
                        const centerZ = (v0[2] + v1[2] + v2[2]) / 3;
                        
                        // Check distance from camera
                        const dx = centerX - cameraPos[0];
                        const dy = centerY - cameraPos[1];
                        const dz = centerZ - cameraPos[2];
                        const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                        
                        // Skip this triangle if too close to camera
                        if (distance < filterDistance) {
                            continue;
                        }
                    }
                    
                    // Add vertices if not already added
                    const vertexIndices = [i0, i1, i2];
                    const newIndices = [];
                    
                    for (const oldIndex of vertexIndices) {
                        if (!oldToNewVertexMap.has(oldIndex)) {
                            // Add new vertex
                            const vertexOffset = oldIndex * 3;
                            filteredVertices.push(
                                vertices[vertexOffset],
                                vertices[vertexOffset + 1],
                                vertices[vertexOffset + 2]
                            );
                            filteredNormals.push(
                                normals[vertexOffset],
                                normals[vertexOffset + 1],
                                normals[vertexOffset + 2]
                            );
                            filteredColors.push(
                                colors[vertexOffset],
                                colors[vertexOffset + 1],
                                colors[vertexOffset + 2]
                            );
                            
                            oldToNewVertexMap.set(oldIndex, newVertexIndex);
                            newIndices.push(newVertexIndex);
                            newVertexIndex++;
                        } else {
                            newIndices.push(oldToNewVertexMap.get(oldIndex));
                        }
                    }
                    
                    // Add triangle indices
                    filteredIndices.push(newIndices[0], newIndices[1], newIndices[2]);
                }
                
                // Update render state with filtered data
                this.renderState.vertices = filteredVertices;
                this.renderState.normals = filteredNormals;
                this.renderState.colors = filteredColors;
                this.renderState.indices = filteredIndices;
                
                // Log filtering results occasionally
                if (this.meshUpdatesReceived % 60 === 0) {
                    const originalTriangles = indices.length / 3;
                    const filteredTriangles = filteredIndices.length / 3;
                    const hiddenTriangles = originalTriangles - filteredTriangles;
                    console.log(`üëÅÔ∏è Filtered ${hiddenTriangles}/${originalTriangles} triangles (${(hiddenTriangles/originalTriangles*100).toFixed(1)}% hidden for first-person view)`);
                }
            }

            setupWebGL() {
                this.canvas = document.getElementById('canvas');
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;

                this.gl = this.canvas.getContext('webgl') || this.canvas.getContext('experimental-webgl');
                if (!this.gl) {
                    alert('WebGL not supported');
                    return;
                }

                this.gl.getExtension('OES_element_index_uint');

                const vertexShaderSource = `
                    attribute vec3 a_position;
                    attribute vec3 a_normal;
                    attribute vec3 a_color;
                    uniform mat4 u_modelViewMatrix;
                    uniform mat4 u_projectionMatrix;
                    uniform mat3 u_normalMatrix;
                    varying vec3 v_normal;
                    varying vec3 v_color;
                    void main() {
                        gl_Position = u_projectionMatrix * u_modelViewMatrix * vec4(a_position, 1.0);
                        v_normal = normalize(u_normalMatrix * a_normal);
                        v_color = a_color;
                    }
                `;

                const fragmentShaderSource = `
                    precision mediump float;
                    varying vec3 v_normal;
                    varying vec3 v_color;
                    uniform vec3 u_lightDirection;
                    uniform vec3 u_lightColor;
                    uniform vec3 u_ambientColor;
                    void main() {
                        float lightFactor = max(dot(v_normal, u_lightDirection), 0.0);
                        vec3 color = v_color * (u_ambientColor + u_lightColor * lightFactor);
                        gl_FragColor = vec4(color, 1.0);
                    }
                `;

                const vertexShader = this.createShader(this.gl.VERTEX_SHADER, vertexShaderSource);
                const fragmentShader = this.createShader(this.gl.FRAGMENT_SHADER, fragmentShaderSource);
                this.program = this.createProgram(vertexShader, fragmentShader);

                this.programInfo = {
                    attribLocations: {
                        position: this.gl.getAttribLocation(this.program, 'a_position'),
                        normal: this.gl.getAttribLocation(this.program, 'a_normal'),
                        color: this.gl.getAttribLocation(this.program, 'a_color'),
                    },
                    uniformLocations: {
                        modelViewMatrix: this.gl.getUniformLocation(this.program, 'u_modelViewMatrix'),
                        projectionMatrix: this.gl.getUniformLocation(this.program, 'u_projectionMatrix'),
                        normalMatrix: this.gl.getUniformLocation(this.program, 'u_normalMatrix'),
                        lightDirection: this.gl.getUniformLocation(this.program, 'u_lightDirection'),
                        lightColor: this.gl.getUniformLocation(this.program, 'u_lightColor'),
                        ambientColor: this.gl.getUniformLocation(this.program, 'u_ambientColor'),
                    },
                };

                this.buffers = {
                    position: this.gl.createBuffer(),
                    normal: this.gl.createBuffer(),
                    color: this.gl.createBuffer(),
                    indices: this.gl.createBuffer(),
                    indexCount: 0,
                    indexType: this.gl.UNSIGNED_SHORT
                };
            }

            createShader(type, source) {
                const shader = this.gl.createShader(type);
                this.gl.shaderSource(shader, source);
                this.gl.compileShader(shader);

                if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
                    console.error('Shader compile error:', this.gl.getShaderInfoLog(shader));
                    this.gl.deleteShader(shader);
                    return null;
                }
                return shader;
            }

            createProgram(vertexShader, fragmentShader) {
                const program = this.gl.createProgram();
                this.gl.attachShader(program, vertexShader);
                this.gl.attachShader(program, fragmentShader);
                this.gl.linkProgram(program);

                if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {
                    console.error('Program link error:', this.gl.getProgramInfoLog(program));
                    this.gl.deleteProgram(program);
                    return null;
                }
                return program;
            }

            setupInput() {
                document.addEventListener('keydown', (e) => {
                    const key = e.key.toLowerCase();
                    if (key === 'escape') {
                        if (document.exitPointerLock) document.exitPointerLock();
                        return;
                    }

                    if (key === 't') {
                        this.interpolation.smoothMode = !this.interpolation.smoothMode;
                        console.log(`üé¨ Interpolation mode: ${this.interpolation.smoothMode ? 'SMOOTH' : 'RAW'}`);
                        return;
                    }

                    if (key === 'c') {
                        this.interpolation.colorMode = !this.interpolation.colorMode;
                        console.log(`üé® Color mode: ${this.interpolation.colorMode ? 'COLORED + DOTS' : 'GRAY ONLY'}`);
                        return;
                    }

                    if (key in this.keys && !this.keys[key]) {
                        this.keys[key] = true;
                    }

                    this.sendToServer('input', { type: 'keydown', key });
                    if (key === ' ') e.preventDefault();
                });

                document.addEventListener('keyup', (e) => {
                    const key = e.key.toLowerCase();
                    if (key in this.keys && this.keys[key]) {
                        this.keys[key] = false;
                    }
                    this.sendToServer('input', { type: 'keyup', key });
                });

                this.canvas.addEventListener('click', (e) => {
                    e.preventDefault();
                    if (!this.pointerLocked) {
                        this.requestPointerLock();
                    } else {
                        this.sendToServer('input', {
                            type: 'shoot',
                            cameraPos: this.camera.pos,
                            cameraDir: this.getCameraDirection()
                        });
                    }
                });

                document.addEventListener('mousemove', (e) => {
                    if (!this.pointerLocked) return;

                    this.camera.yaw -= e.movementX * MOUSE_SENS;
                    this.camera.pitch -= e.movementY * MOUSE_SENS;
                    this.camera.pitch = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, this.camera.pitch));

                    this.sendToServer('input', {
                        type: 'camera',
                        yaw: this.camera.yaw,
                        pitch: this.camera.pitch
                    });
                });

                document.addEventListener('pointerlockchange', () => {
                    this.pointerLocked = document.pointerLockElement === this.canvas;
                });

                this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
            }

            requestPointerLock() {
                if (this.canvas.requestPointerLock) this.canvas.requestPointerLock();
            }

            getCameraDirection() {
                return [
                    Math.cos(this.camera.pitch) * Math.sin(this.camera.yaw),
                    Math.sin(this.camera.pitch),
                    Math.cos(this.camera.pitch) * Math.cos(this.camera.yaw)
                ];
            }

            updateBuffers() {
                const bufferStartTime = performance.now();
                const gl = this.gl;

                const positionStartTime = performance.now();
                gl.bindBuffer(gl.ARRAY_BUFFER, this.buffers.position);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.renderState.vertices), gl.DYNAMIC_DRAW);
                const positionTime = performance.now() - positionStartTime;

                const normalStartTime = performance.now();
                gl.bindBuffer(gl.ARRAY_BUFFER, this.buffers.normal);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.renderState.normals), gl.DYNAMIC_DRAW);
                const normalTime = performance.now() - normalStartTime;

                const colorStartTime = performance.now();
                gl.bindBuffer(gl.ARRAY_BUFFER, this.buffers.color);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.renderState.colors), gl.DYNAMIC_DRAW);
                const colorTime = performance.now() - colorStartTime;

                const indexStartTime = performance.now();
                const indexArray = this.renderState.indices.length > 65535 ? new Uint32Array(this.renderState.indices) : new Uint16Array(this.renderState.indices);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffers.indices);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indexArray, gl.DYNAMIC_DRAW);
                this.buffers.indexCount = this.renderState.indices.length;
                this.buffers.indexType = this.renderState.indices.length > 65535 ? gl.UNSIGNED_INT : gl.UNSIGNED_SHORT;
                const indexTime = performance.now() - indexStartTime;

                const totalBufferTime = performance.now() - bufferStartTime;

                // Log if buffer updates are slow
                if (totalBufferTime > 5) {
                    console.log(`üêå Slow updateBuffers: Total=${totalBufferTime.toFixed(2)}ms, Position=${positionTime.toFixed(2)}ms, Normal=${normalTime.toFixed(2)}ms, Color=${colorTime.toFixed(2)}ms, Index=${indexTime.toFixed(2)}ms, VertexCount=${this.renderState.vertices.length/3}, IndexCount=${this.renderState.indices.length}`);
                }
            }

            updateDebugDisplay() {
                const debugDiv = document.getElementById('debug');
                const interpolatedVoxels = this.getInterpolatedVoxels();
                const movingVoxelCount = interpolatedVoxels.length;

                // Count moving voxels (only projectiles and debris now)
                const projectileCount = interpolatedVoxels.filter(v => v.isProjectile).length;
                const debrisCount = interpolatedVoxels.filter(v => !v.isProjectile).length;

                const mode = this.interpolation.smoothMode ? 'SMOOTH' : 'RAW';
                const colorMode = this.interpolation.colorMode ? 'COLORED' : 'GRAY';
                const serverStatus = this.connected ? 'üü¢ CONNECTED' : 'üî¥ DISCONNECTED';
                const totalServerVoxels = this.renderState.debugInfo.playerVoxels || 0;

                // Unified rendering statistics
                const terrainVertices = this.renderState.vertices.length / 3;
                const terrainTriangles = this.renderState.indices.length / 3;
                const playersWithPositions = this.playerPositions.size;

                // Frame timing statistics
                const timing = this.lastFrameTiming || {};
                const frameTime = timing.total || 0;
                const slowestProcess = this.findSlowestProcess(timing);

                debugDiv.innerHTML = `Server: ${totalServerVoxels} total player voxels (server-side), ${this.renderState.debugInfo.activeVoxels} moving, ${this.renderState.debugInfo.totalPlayers} players (50 TPS) ${serverStatus}<br>
Client: ${this.frameCount}fps ${mode} rendering (GREEDY MESHED PIPELINE)<br>
MyID: ${this.myPlayerId || 'unknown'}<br>
Unified Mesh: ${terrainVertices} vertices, ${terrainTriangles} triangles (terrain + ${this.renderState.debugInfo.totalPlayers} greedy meshed players)<br>
Players: ${playersWithPositions} with positions, HOLLOW ORANGE SHELLS (exterior faces only)<br>
Mesh Updates: ${this.meshUpdatesReceived} received (full regeneration per update)<br>
Moving Objects: ${movingVoxelCount} total (${projectileCount} projectiles, ${debrisCount} debris)<br>
Architecture: TERRAIN + GREEDY MESHED PLAYERS = SAME MESH, Moving = dynamic per-frame<br>
<span style="color: yellow;">üêå BOTTLENECK: ${slowestProcess.name} = ${slowestProcess.time.toFixed(2)}ms (${Math.round((slowestProcess.time/frameTime)*100)}% of frame)</span><br>
Frame timing: Total=${frameTime.toFixed(1)}ms, UnifiedRender=${(timing.terrain||0).toFixed(1)}ms, VoxelRender=${(timing.voxelRender||0).toFixed(1)}ms<br>
Visual: ${colorMode} mode, ${this.interpolation.colorMode ? 'dots ON' : 'dots OFF'}, first-person view<br>
Optimization: Players as hollow shells (greedy meshed, exterior faces only)<br>
Delay: ${this.interpolation.renderDelay}ms behind server<br>
Cam: ${this.camera.smoothPos[0].toFixed(1)}, ${this.camera.smoothPos[1].toFixed(1)}, ${this.camera.smoothPos[2].toFixed(1)}<br>
<span style="color: cyan;">T: SMOOTH/RAW | C: COLORED/GRAY</span><br>
<span style="color: lime;">‚úÖ GREEDY MESHED: Players are hollow shells = clean first-person view!</span>`;
            }

            findSlowestProcess(timing) {
                const processes = [
                    { name: 'Camera', time: timing.camera || 0 },
                    { name: 'VoxelInterpolation', time: timing.voxelInterpolation || 0 },
                    { name: 'VoxelRender', time: timing.voxelRender || 0 },
                    { name: 'UnifiedTerrain', time: timing.terrain || 0 },
                    { name: 'WebGLSetup', time: timing.webglSetup || 0 },
                    { name: 'Dots', time: timing.dots || 0 },
                    { name: 'Input', time: timing.input || 0 },
                    { name: 'Ping', time: timing.ping || 0 },
                    { name: 'FPS', time: timing.fps || 0 }
                ];

                return processes.reduce((slowest, current) => 
                    current.time > slowest.time ? current : slowest
                );
            }

            // Ping system
            sendPing() {
                if (!this.connected) return;
                const id = Math.random().toString(36).substr(2, 9);
                this.pingRequests.set(id, performance.now());
                this.sendToServer('ping', { id });
            }

            handlePong(data) {
                const sendTime = this.pingRequests.get(data.id);
                if (sendTime) {
                    this.ping = performance.now() - sendTime;
                    this.pingRequests.delete(data.id);
                    this.updatePingDisplay();
                }
            }

            updatePingDisplay() {
                const pingDiv = document.getElementById('ping-display');
                const color = this.ping < 50 ? 'lime' : this.ping < 100 ? 'yellow' : 'red';
                pingDiv.innerHTML = `üì° Ping: ${this.ping.toFixed(0)}ms`;
                pingDiv.style.color = color;
            }

            render(currentTime) {
                const frameStartTime = performance.now();
                currentTime /= 1000;
                const dt = currentTime - this.lastFrameTime;
                this.lastFrameTime = currentTime;

                // Time ping handling
                const pingStartTime = performance.now();
                if (currentTime - this.lastPingTime > 2.0) {
                    this.sendPing();
                    this.lastPingTime = currentTime;
                }
                const pingTime = performance.now() - pingStartTime;

                // Time camera interpolation
                const cameraStartTime = performance.now();
                const interpolatedPos = this.getInterpolatedCameraPos();
                this.camera.pos = interpolatedPos;

                // Apply smoothing to ALL axes for buttery smooth movement
                const smoothing = 8.0;
                this.camera.smoothPos[0] += (interpolatedPos[0] - this.camera.smoothPos[0]) * smoothing * dt;
                this.camera.smoothPos[1] += (interpolatedPos[1] - this.camera.smoothPos[1]) * smoothing * dt;
                this.camera.smoothPos[2] += (interpolatedPos[2] - this.camera.smoothPos[2]) * smoothing * dt;
                const cameraTime = performance.now() - cameraStartTime;

                // Time input sending
                const inputStartTime = performance.now();
                const now = performance.now();
                if (now - this.lastInputSend > 50) { // 20Hz input updates
                    this.sendToServer('inputState', { keys: this.keys });
                    this.lastInputSend = now;
                }
                const inputTime = performance.now() - inputStartTime;

                // Time WebGL setup
                const webglSetupStartTime = performance.now();
                this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
                this.gl.enable(this.gl.DEPTH_TEST);
                this.gl.clearColor(0.5, 0.7, 1.0, 1.0);
                this.gl.useProgram(this.program);

                const projectionMatrix = this.createPerspectiveMatrix(
                    Math.PI / 3,
                    this.canvas.width / this.canvas.height,
                    0.1,
                    128 * 8
                );

                const cameraDir = this.getCameraDirection();
                const eye = [this.camera.smoothPos[0], this.camera.smoothPos[1], this.camera.smoothPos[2]];
                const center = [eye[0] + cameraDir[0], eye[1] + cameraDir[1], eye[2] + cameraDir[2]];
                const modelViewMatrix = this.createLookAtMatrix(eye, center, [0, 1, 0]);
                const normalMatrix = this.normalFromMat4(modelViewMatrix);

                this.gl.uniformMatrix4fv(this.programInfo.uniformLocations.projectionMatrix, false, projectionMatrix);
                this.gl.uniformMatrix4fv(this.programInfo.uniformLocations.modelViewMatrix, false, modelViewMatrix);
                this.gl.uniformMatrix3fv(this.programInfo.uniformLocations.normalMatrix, false, normalMatrix);

                // Fixed lighting - normalized light direction from above-front, more ambient light
                this.gl.uniform3f(this.programInfo.uniformLocations.lightDirection, 0.4, 0.8, 0.4); // Normalized: pointing down and forward
                this.gl.uniform3f(this.programInfo.uniformLocations.lightColor, 1.0, 1.0, 1.0); // Bright white light
                this.gl.uniform3f(this.programInfo.uniformLocations.ambientColor, 0.4, 0.4, 0.4); // Higher ambient for visibility
                const webglSetupTime = performance.now() - webglSetupStartTime;

                // Time unified terrain + players rendering
                const terrainStartTime = performance.now();
                if (this.buffers.indexCount > 0) {
                    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers.position);
                    this.gl.enableVertexAttribArray(this.programInfo.attribLocations.position);
                    this.gl.vertexAttribPointer(this.programInfo.attribLocations.position, 3, this.gl.FLOAT, false, 0, 0);

                    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers.normal);
                    this.gl.enableVertexAttribArray(this.programInfo.attribLocations.normal);
                    this.gl.vertexAttribPointer(this.programInfo.attribLocations.normal, 3, this.gl.FLOAT, false, 0, 0);

                    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers.color);
                    this.gl.enableVertexAttribArray(this.programInfo.attribLocations.color);
                    this.gl.vertexAttribPointer(this.programInfo.attribLocations.color, 3, this.gl.FLOAT, false, 0, 0);

                    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.buffers.indices);
                    this.gl.drawElements(this.gl.TRIANGLES, this.buffers.indexCount, this.buffers.indexType, 0);
                }
                const terrainTime = performance.now() - terrainStartTime;

                // Time voxel interpolation (moving voxels only now)
                const voxelInterpolationStartTime = performance.now();
                const interpolatedVoxels = this.getInterpolatedVoxels();
                const voxelInterpolationTime = performance.now() - voxelInterpolationStartTime;

                // Time moving voxel rendering (projectiles and debris only)
                const voxelRenderStartTime = performance.now();
                this.drawAllVoxels3D(modelViewMatrix, projectionMatrix);
                const voxelRenderTime = performance.now() - voxelRenderStartTime;

                // Time dot rendering (if enabled)
                const dotStartTime = performance.now();
                if (this.interpolation.colorMode) {
                    this.drawAllVoxelDots(modelViewMatrix, projectionMatrix);
                }
                const dotTime = performance.now() - dotStartTime;

                // Time FPS/debug updates
                const fpsStartTime = performance.now();
                this.frameCount++;
                if (currentTime - this.lastFpsTime >= 1.0) {
                    const fps = this.frameCount / (currentTime - this.lastFpsTime);
                    document.getElementById('info').textContent = `FPS: ${fps.toFixed(1)}`;
                    this.frameCount = 0;
                    this.lastFpsTime = currentTime;
                }
                const fpsTime = performance.now() - fpsStartTime;

                const totalFrameTime = performance.now() - frameStartTime;

                // Store timing data for debug display
                this.lastFrameTiming = {
                    total: totalFrameTime,
                    ping: pingTime,
                    camera: cameraTime,
                    input: inputTime,
                    webglSetup: webglSetupTime,
                    terrain: terrainTime,
                    voxelInterpolation: voxelInterpolationTime,
                    voxelRender: voxelRenderTime,
                    dots: dotTime,
                    fps: fpsTime,
                    voxelCount: interpolatedVoxels.length
                };

                // Log timing every 60 frames (1 second at 60fps)
                this.timingFrameCount = (this.timingFrameCount || 0) + 1;
                if (this.timingFrameCount % 60 === 0) {
                    console.log(`üé¨ Client timing: Total=${totalFrameTime.toFixed(2)}ms, Camera=${cameraTime.toFixed(2)}ms, VoxelInterp=${voxelInterpolationTime.toFixed(2)}ms, VoxelRender=${voxelRenderTime.toFixed(2)}ms, UnifiedTerrain=${terrainTime.toFixed(2)}ms, MovingVoxels=${interpolatedVoxels.length}, TerrainVertices=${this.renderState.vertices.length/3}`);
                }

                requestAnimationFrame((time) => this.render(time));
            }

            // Frustum culling - only render voxels visible to camera
            isVoxelInFrustum(voxelPos, viewMatrix, projMatrix) {
                // Transform voxel position to clip space
                const clipPos = this.transformVec4(voxelPos, viewMatrix, projMatrix);

                // If behind camera, don't render
                if (clipPos[3] <= 0) return false;

                // Convert to normalized device coordinates
                const ndcX = clipPos[0] / clipPos[3];
                const ndcY = clipPos[1] / clipPos[3];
                const ndcZ = clipPos[2] / clipPos[3];

                // Check if within frustum bounds (with small margin for voxel size)
                const margin = 0.1;
                return (
                    ndcX >= -1 - margin && ndcX <= 1 + margin &&
                    ndcY >= -1 - margin && ndcY <= 1 + margin &&
                    ndcZ >= -1 && ndcZ <= 1
                );
            }

            // Distance culling - don't render voxels too far away
            isVoxelInRange(voxelPos, cameraPos, maxDistance = 200) {
                const dx = voxelPos[0] - cameraPos[0];
                const dy = voxelPos[1] - cameraPos[1];
                const dz = voxelPos[2] - cameraPos[2];
                const distanceSquared = dx*dx + dy*dy + dz*dz;
                return distanceSquared <= maxDistance * maxDistance;
            }

            drawAllVoxels3D(viewMatrix, projMatrix) {
                const voxels = this.getInterpolatedVoxels();
                if (voxels.length === 0) return;

                const vertices = [], normals = [], colors = [], indices = [];
                let culledCount = 0, totalCount = 0;

                // Only render moving voxels (projectiles and debris)
                // Players are now part of the unified terrain mesh!
                for (const voxel of voxels) {
                    totalCount++;

                    // Frustum culling - only render visible voxels
                    if (!this.isVoxelInFrustum(voxel.pos, viewMatrix, projMatrix)) {
                        culledCount++;
                        continue;
                    }

                    // Distance culling - don't render very far voxels
                    if (!this.isVoxelInRange(voxel.pos, this.camera.smoothPos, 150)) {
                        culledCount++;
                        continue;
                    }

                    const alpha = voxel.alpha || 1.0;
                    let color;

                    if (this.interpolation.colorMode) {
                        if (voxel.isProjectile) {
                            color = [0, 1, 0]; // Green for projectiles
                        } else {
                            color = [1, 1, 0]; // Yellow for debris
                        }
                    } else {
                        color = [0.6, 0.6, 0.6]; // Gray for everything
                    }

                    const finalColor = [color[0] * alpha, color[1] * alpha, color[2] * alpha];
                    this.addCube(vertices, normals, colors, indices, voxel.pos[0], voxel.pos[1], voxel.pos[2], finalColor);
                }

                if (vertices.length === 0) return;

                this.renderGeometry(vertices, normals, colors, indices);
            }

            drawAllVoxelDots(viewMatrix, projMatrix) {
                const voxels = this.getInterpolatedVoxels();

                for (const voxel of voxels) {
                    // Use same culling as 3D rendering
                    if (!this.isVoxelInFrustum(voxel.pos, viewMatrix, projMatrix)) {
                        continue;
                    }

                    if (!this.isVoxelInRange(voxel.pos, this.camera.smoothPos, 150)) {
                        continue;
                    }

                    const screenPos = this.worldToScreen(voxel.pos, viewMatrix, projMatrix);
                    if (screenPos) {
                        let color, size;

                        if (voxel.isProjectile) {
                            color = 'lime';
                            size = 12;
                        } else {
                            color = 'yellow';
                            size = 6;
                        }

                        const alpha = voxel.alpha || 1.0;
                        this.draw2DDot(screenPos[0], screenPos[1], color, size * alpha);
                    }
                }
            }

            addCube(vertices, normals, colors, indices, x, y, z, color) {
                const s = 0.5;
                const faces = [
                    { verts: [[x-s,y-s,z+s], [x+s,y-s,z+s], [x+s,y+s,z+s], [x-s,y+s,z+s]], norm: [0,0,1] },
                    { verts: [[x+s,y-s,z-s], [x-s,y-s,z-s], [x-s,y+s,z-s], [x+s,y+s,z-s]], norm: [0,0,-1] },
                    { verts: [[x-s,y+s,z-s], [x-s,y+s,z+s], [x+s,y+s,z+s], [x+s,y+s,z-s]], norm: [0,1,0] },
                    { verts: [[x-s,y-s,z+s], [x-s,y-s,z-s], [x+s,y-s,z-s], [x+s,y-s,z+s]], norm: [0,-1,0] },
                    { verts: [[x+s,y-s,z+s], [x+s,y-s,z-s], [x+s,y+s,z-s], [x+s,y+s,z+s]], norm: [1,0,0] },
                    { verts: [[x-s,y-s,z-s], [x-s,y-s,z+s], [x-s,y+s,z+s], [x-s,y+s,z-s]], norm: [-1,0,0] }
                ];

                for (const face of faces) {
                    this.addFace(vertices, normals, colors, indices, face.verts[0], face.verts[1], face.verts[2], face.verts[3], face.norm, color);
                }
            }

            addFace(vertices, normals, colors, indices, v0, v1, v2, v3, n, color) {
                const i0 = vertices.length / 3;
                [v0, v1, v2, v3].forEach(v => {
                    vertices.push(v[0], v[1], v[2]);
                    normals.push(n[0], n[1], n[2]);
                    colors.push(color[0], color[1], color[2]);
                });
                indices.push(i0, i0 + 1, i0 + 2, i0, i0 + 2, i0 + 3);
            }

            renderGeometry(vertices, normals, colors, indices) {
                const tempBuffers = {
                    vertex: this.gl.createBuffer(),
                    normal: this.gl.createBuffer(),
                    color: this.gl.createBuffer(),
                    index: this.gl.createBuffer()
                };

                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, tempBuffers.vertex);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertices), this.gl.DYNAMIC_DRAW);
                this.gl.enableVertexAttribArray(this.programInfo.attribLocations.position);
                this.gl.vertexAttribPointer(this.programInfo.attribLocations.position, 3, this.gl.FLOAT, false, 0, 0);

                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, tempBuffers.normal);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(normals), this.gl.DYNAMIC_DRAW);
                this.gl.enableVertexAttribArray(this.programInfo.attribLocations.normal);
                this.gl.vertexAttribPointer(this.programInfo.attribLocations.normal, 3, this.gl.FLOAT, false, 0, 0);

                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, tempBuffers.color);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(colors), this.gl.DYNAMIC_DRAW);
                this.gl.enableVertexAttribArray(this.programInfo.attribLocations.color);
                this.gl.vertexAttribPointer(this.programInfo.attribLocations.color, 3, this.gl.FLOAT, false, 0, 0);

                const indexArray = indices.length > 65535 ? new Uint32Array(indices) : new Uint16Array(indices);
                const indexType = indices.length > 65535 ? this.gl.UNSIGNED_INT : this.gl.UNSIGNED_SHORT;

                this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, tempBuffers.index);
                this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, indexArray, this.gl.DYNAMIC_DRAW);

                this.gl.drawElements(this.gl.TRIANGLES, indices.length, indexType, 0);

                // Clean up
                Object.values(tempBuffers).forEach(buffer => this.gl.deleteBuffer(buffer));
            }

            worldToScreen(worldPos, viewMatrix, projMatrix) {
                const clipPos = this.transformVec4(worldPos, viewMatrix, projMatrix);
                if (clipPos[3] <= 0) return null;

                const ndcX = clipPos[0] / clipPos[3];
                const ndcY = clipPos[1] / clipPos[3];

                if (ndcX < -1 || ndcX > 1 || ndcY < -1 || ndcY > 1) return null;

                const screenX = (ndcX + 1) * 0.5 * this.canvas.width;
                const screenY = (1 - ndcY) * 0.5 * this.canvas.height;

                return [screenX, screenY];
            }

            transformVec4(pos, view, proj) {
                const viewPos = [
                    view[0] * pos[0] + view[4] * pos[1] + view[8] * pos[2] + view[12],
                    view[1] * pos[0] + view[5] * pos[1] + view[9] * pos[2] + view[13],
                    view[2] * pos[0] + view[6] * pos[1] + view[10] * pos[2] + view[14],
                    view[3] * pos[0] + view[7] * pos[1] + view[11] * pos[2] + view[15]
                ];

                return [
                    proj[0] * viewPos[0] + proj[4] * viewPos[1] + proj[8] * viewPos[2] + proj[12] * viewPos[3],
                    proj[1] * viewPos[0] + proj[5] * viewPos[1] + proj[9] * viewPos[2] + proj[13] * viewPos[3],
                    proj[2] * viewPos[0] + proj[6] * viewPos[1] + proj[10] * viewPos[2] + proj[14] * viewPos[3],
                    proj[3] * viewPos[0] + proj[7] * viewPos[1] + proj[11] * viewPos[2] + proj[15] * viewPos[3]
                ];
            }

            draw2DDot(x, y, color, size) {
                this.gl.disable(this.gl.DEPTH_TEST);

                const orthoMatrix = new Float32Array(16);
                orthoMatrix[0] = 2 / this.canvas.width;
                orthoMatrix[5] = -2 / this.canvas.height;
                orthoMatrix[10] = -1;
                orthoMatrix[12] = -1;
                orthoMatrix[13] = 1;
                orthoMatrix[15] = 1;

                this.gl.useProgram(this.program);
                this.gl.uniformMatrix4fv(this.programInfo.uniformLocations.projectionMatrix, false, orthoMatrix);
                this.gl.uniformMatrix4fv(this.programInfo.uniformLocations.modelViewMatrix, false, this.createIdentityMatrix());
                this.gl.uniformMatrix3fv(this.programInfo.uniformLocations.normalMatrix, false, this.createIdentityMatrix3());

                const half = size / 2;
                const dotVerts = new Float32Array([
                    x - half, y - half, 0,
                    x + half, y - half, 0,
                    x + half, y + half, 0,
                    x - half, y + half, 0
                ]);
                const dotNormals = new Float32Array([0,0,1, 0,0,1, 0,0,1, 0,0,1]);
                const dotIndices = new Uint16Array([0,1,2, 0,2,3]);

                const tempBuffer = this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, tempBuffer);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, dotVerts, this.gl.DYNAMIC_DRAW);
                this.gl.enableVertexAttribArray(this.programInfo.attribLocations.position);
                this.gl.vertexAttribPointer(this.programInfo.attribLocations.position, 3, this.gl.FLOAT, false, 0, 0);

                const tempNormalBuffer = this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, tempNormalBuffer);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, dotNormals, this.gl.DYNAMIC_DRAW);
                this.gl.enableVertexAttribArray(this.programInfo.attribLocations.normal);
                this.gl.vertexAttribPointer(this.programInfo.attribLocations.normal, 3, this.gl.FLOAT, false, 0, 0);

                this.gl.disableVertexAttribArray(this.programInfo.attribLocations.color);
                if (color === 'lime') this.gl.vertexAttrib3f(this.programInfo.attribLocations.color, 0, 1, 0);
                else if (color === 'yellow') this.gl.vertexAttrib3f(this.programInfo.attribLocations.color, 1, 1, 0);
                else if (color === 'cyan') this.gl.vertexAttrib3f(this.programInfo.attribLocations.color, 0, 1, 1);
                else if (color === 'orange') this.gl.vertexAttrib3f(this.programInfo.attribLocations.color, 1, 0.5, 0);
                else this.gl.vertexAttrib3f(this.programInfo.attribLocations.color, 1, 1, 1);

                const tempIndexBuffer = this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, tempIndexBuffer);
                this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, dotIndices, this.gl.DYNAMIC_DRAW);

                this.gl.drawElements(this.gl.TRIANGLES, 6, this.gl.UNSIGNED_SHORT, 0);

                this.gl.deleteBuffer(tempBuffer);
                this.gl.deleteBuffer(tempNormalBuffer);
                this.gl.deleteBuffer(tempIndexBuffer);

                this.gl.enable(this.gl.DEPTH_TEST);
            }

            // Matrix utilities
            createPerspectiveMatrix(fovy, aspect, near, far) {
                const out = new Float32Array(16);
                const f = 1.0 / Math.tan(fovy / 2), nf = 1 / (near - far);
                out[0] = f / aspect;
                out[5] = f;
                out[10] = (far + near) * nf;
                out[11] = -1;
                out[14] = 2 * far * near * nf;
                return out;
            }

            createLookAtMatrix(eye, center, up) {
                const out = new Float32Array(16);
                let z0 = eye[0] - center[0], z1 = eye[1] - center[1], z2 = eye[2] - center[2];
                let len = 1 / Math.sqrt(z0*z0 + z1*z1 + z2*z2);
                z0 *= len; z1 *= len; z2 *= len;

                let x0 = up[1] * z2 - up[2] * z1, x1 = up[2] * z0 - up[0] * z2, x2 = up[0] * z1 - up[1] * z0;
                len = Math.sqrt(x0*x0 + x1*x1 + x2*x2);
                if (len) { len = 1 / len; x0 *= len; x1 *= len; x2 *= len; }

                let y0 = z1 * x2 - z2 * x1, y1 = z2 * x0 - z0 * x2, y2 = z0 * x1 - z1 * x0;
                len = Math.sqrt(y0*y0 + y1*y1 + y2*y2);
                if (len) { len = 1 / len; y0 *= len; y1 *= len; y2 *= len; }

                out[0] = x0; out[1] = y0; out[2] = z0; out[3] = 0;
                out[4] = x1; out[5] = y1; out[6] = z1; out[7] = 0;
                out[8] = x2; out[9] = y2; out[10] = z2; out[11] = 0;
                out[12] = -(x0 * eye[0] + x1 * eye[1] + x2 * eye[2]);
                out[13] = -(y0 * eye[0] + y1 * eye[1] + y2 * eye[2]);
                out[14] = -(z0 * eye[0] + z1 * eye[1] + z2 * eye[2]);
                out[15] = 1;
                return out;
            }

            normalFromMat4(a) {
                const out = new Float32Array(9);
                const a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[4], a11 = a[5], a12 = a[6], a20 = a[8], a21 = a[9], a22 = a[10];

                const b01 = a22 * a11 - a12 * a21, b11 = -a22 * a10 + a12 * a20, b21 = a21 * a10 - a11 * a20;

                let det = a00 * b01 + a01 * b11 + a02 * b21;
                if (!det) return out;
                det = 1.0 / det;

                out[0] = b01 * det;
                out[1] = (-a22 * a01 + a02 * a21) * det;
                out[2] = (a12 * a01 - a02 * a11) * det;
                out[3] = b11 * det;
                out[4] = (a22 * a00 - a02 * a20) * det;
                out[5] = (-a12 * a00 + a02 * a10) * det;
                out[6] = b21 * det;
                out[7] = (-a21 * a00 + a01 * a20) * det;
                out[8] = (a11 * a00 - a01 * a10) * det;
                return out;
            }

            createIdentityMatrix() {
                const out = new Float32Array(16);
                out[0] = out[5] = out[10] = out[15] = 1;
                return out;
            }

            createIdentityMatrix3() {
                const out = new Float32Array(9);
                out[0] = out[4] = out[8] = 1;
                return out;
            }
        }

        // Initialize
        let client;
        window.addEventListener('load', () => {
            console.log('üöÄ Starting Multiplayer Voxel Client (UNIFIED RENDERING)...');
            client = new MultiplayerVoxelClient();
            client.render(performance.now());
        });

        window.addEventListener('resize', () => {
            if (client) {
                client.canvas.width = window.innerWidth;
                client.canvas.height = window.innerHeight;
            }
        });
    </script>
</body>
</html>